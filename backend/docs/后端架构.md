

## 架构图

| 层级          | 模块名称          | 职责描述                                                     |
| :------------ | :---------------- | :----------------------------------------------------------- |
| **L1 接口层** | **FastAPI**       | 处理 HTTP 请求、视频流推流 (MJPEG)、权限验证                 |
| **L2 业务层** | **Service Logic** | 协调摄像头、数据库和 AI 引擎。包含**后台守护线程** (自动开门逻辑) |
| **L3 核心层** | **Core Wrapper**  | `FaceEngine` (Python) + `GlobalCamera` (单例摄像头管理)      |
| **L4 驱动层** | **Native .so**    | C++ 编写的动态库，负责 RKNN 推理、OpenCV 图像处理            |
| **L5 数据层** | **SQLite**        | 存储用户信息、特征向量 (BLOB)、进出日志                      |

## 后端结构

```bash
backend/
├── main.py                  # [入口] FastAPI App, 启动后台线程
├── requirements.txt         # 依赖: fastapi, uvicorn, numpy, opencv-python-headless
├── config.py                # 配置: 阈值, 摄像头ID, GPIO引脚号
│
├── core/                    # [核心逻辑]
│   ├── __init__.py
│   ├── face_engine.py       # ★ Python Wrapper (调用 ctypes)
│   ├── camera.py            # ★ GlobalCamera (单例, 管理 cv2.VideoCapture)
│   └── background_task.py   # ★ 自动开门死循环逻辑
│
├── routers/                 # [API 路由]
│   ├── auth.py              # 登录, 修改密码
│   ├── face.py              # /api/face/capture, /api/face/list
│   ├── stream.py            # /api/video_feed
│   └── monitor.py           # /api/logs, /api/recognize (测试用)
│
├── database/                # [数据库]
│   ├── db_manager.py        # SQLite 增删改查封装
│   └── smart_door.db        # 自动生成
│
├── libs/                    # [C++ 产物]
│   └── libface_engine.so    # 从 face_detection 项目编译而来
│
└── models/                  # [AI 模型]
    ├── RetinaFace.rknn
    └── mobilefacenet.rknn
```

### 关键部分



## API 列表

### 模块 A：认证

| HTTP 方法 | URL                          | 功能说明     | 备注                                                 |
| :-------- | :--------------------------- | :----------- | :--------------------------------------------------- |
| **POST**  | `/api/login`                 | 管理员登录   | 输入: `{"pwd": "..."}` <br> 输出: `{"token": "xyz"}` |
| **POST**  | `/api/change_login_password` | 修改登录密码 |                                                      |

### 模块 B：视频流与摄像头

| HTTP 方法 | URL                 | 功能说明          | 备注                          |
| :-------- | :------------------ | :---------------- | :---------------------------- |
| **GET**   | `/api/video_stream` | 提供 MJPEG 视频流 | 前端 `img` 标签直接引用此 URL |

### 模块 C：人脸管理

| HTTP 方法  | URL                 | 功能说明               | 备注                                                         |
| :--------- | :------------------ | :--------------------- | :----------------------------------------------------------- |
| **POST**   | `/api/face/capture` | 触发录入               | 输入: `{"username": "张三"}`<br>**逻辑**：后端收到请求 -> 从全局摄像头对象截取当前这一帧 -> 调 C++ 提取特征 -> 存库 |
| **GET**    | `/api/face/list`    | 获取已录入用户列表     | 返回 `["张三", "李四"]`                                      |
| **DELETE** | `/api/face/reset`   | 重置所有               |                                                              |
| **DELETE** | `/api/face/{name}`  | **新增**。删除指定用户 | 比如 `DELETE /api/face/张三`                                 |

### 模块 D：传统密码与日志

| HTTP 方法  | URL               | 功能说明                 | 备注                         |
| :--------- | :---------------- | :----------------------- | :--------------------------- |
| **POST**   | `/api/code/add`   | 录入开门密码             |                              |
| **DELETE** | `/api/code/reset` | 重置所有密码             |                              |
| **GET**    | `/api/logs`       | 获取开门记录（**可选**） | 返回 JSON 列表供前端渲染表格 |

## 数据流

#### 数据流 A：实时预览 (MJPEG 流)
*用户在手机网页上看到摄像头画面*

1.  **源头**：`GlobalCamera` (OpenCV) 持续读取 `/dev/video0`
2.  **转换**：将 `cv::Mat` (Raw Data) 编码为 `.jpg` 格式 (Bytes)
3.  **传输**：FastAPI 通过生成器 (`yield`) 将 JPG 拼接到 HTTP `multipart/x-mixed-replace` 流中
4.  **终端**：手机浏览器 `<img src="/api/video_feed">` 接收并渲染

> 数据流向：Camera -> Python Memory -> HTTP Stream -> Phone

#### 数据流 B：人脸录入 (Web 触发)
*管理员点击“录入”按钮，将当前画面存入库*

1.  **触发**：手机发送 `POST /api/face/capture` (带用户名)
2.  **截取**：FastAPI 从 `GlobalCamera` 获取**当前最新一帧** (Numpy Array)
3.  **编码**：使用 `cv2.imencode` 将帧转为 **Bytes** (模拟图片文件)
4.  **推理**：调用 `FaceEngine.extract_feature(bytes)`
    
    *C++ 内部*：`imdecode` -> RetinaFace -> Alignment -> MobileFaceNet -> Vector
5.  **存储**：将返回的 `512维 List` 转为二进制 (`tobytes()`) 存入 SQLite。

> 数据流向：Phone (指令) -> Camera Frame -> C++ Engine -> Feature Vector -> SQLite

#### 数据流 C：自动守卫 (后台线程)
*完全脱离手机，设备自主运行的开门逻辑*

1.  **循环**：`Background Thread` 每 100ms 检查一次
2.  **检测**：调用 `GlobalCamera` 判断画面是否有变动 (移动侦测)
3.  **获取**：若有人，获取当前帧 -> `cv2.imencode` -> **Bytes**
4.  **推理**：调用 `FaceEngine.extract_feature(bytes)` (复用同一个引擎实例)
5.  **比对**：从 SQLite 拉取所有用户的向量，计算余弦相似度
6.  **执行**：若相似度 > 0.5，控制 **GPIO** 输出高电平开锁

> 数据流向：Camera -> Background Thread -> C++ Engine -> Vector -> DB Search -> GPIO

## 业务流程

### 路线一：日常自动开门（核心业务）

- **场景**：你走到门口，门自动开了。
- **流程**：
  1. OV5695 摄像头（直连 RK3568）不断采集画面
  2. 后台线程（Python while True 循环）拿到画面
  3. 后台线程 直接调用 C++ 模块 (face_app.extract_feature)
  4. 后台线程 拿着结果去本地数据库比对
  5. 后台线程 比对成功，控制 **GPIO** 引脚，门锁打开
- 特点：极速、本地化、断网也能用、不需要手机参与

### 路线二：HTTP API 交互（管理与测试）

- **场景 A：录入人脸 (/api/face/capture)**
  - 管理员拿着手机，看着网页上的直播，喊一声“看镜头”，然后点“录入”
  - 手机发送 HTTP 指令 -> RK3568 截帧 -> 存入数据库
- **场景 B：远程测试 (api/face/recognize)**
  - 管理员想测试一下系统准不准，或者想远程帮人验证一张照片
  - 管理员在手机/电脑上传一张图片 -> 发送 HTTP 请求 -> RK3568 计算并返回 JSON 结果 ("这是张三，相似度 0.9")
  - **注意**：这个接口通常只返回结果，不触发 GPIO 开门（除非你特意写了逻辑让它开）

## 注意事项（必看）

1. GPIO传统密码录入部分可能来不及做，先把核心的人脸识别部分打通。

