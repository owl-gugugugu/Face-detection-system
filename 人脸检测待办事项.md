### 2. 在 VMWare 上验证需要的环境和步骤

在 VMWare 上，我们无法运行程序（因为没有 NPU，且架构不同），我们的目标是**成功编译出 ARM64 格式的动态库**。

#### 环境准备
1.  交叉编译器：确保 `gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu.tar.gz` 已解压，并记住路径（例如 `/home/topeet/gcc-linaro...`）。
2.  CMake：VMWare Ubuntu 中已安装 CMake (`sudo apt install cmake`)

#### 操作步骤

**第一步：填充第三方库**

将您下载的 ARM64 版本的库文件放入项目目录：

*   face_detection/third_party/rknn/lib/ -> 放入 librknnrt.so (来自 rknpu2/runtime/RK3568/Linux/librknn_api/aarch64/)
*   face_detection/third_party/rknn/include/ -> 放入 rknn_api.h
*   `face_detection/third_party/opencv/` -> 放入交叉编译好的 OpenCV `include` 和 `lib` (包含 `.a` 和 cmake config)

**第二步：修改主 `CMakeLists.txt` 指定交叉编译**

打开 `face_detection/CMakeLists.txt`，在文件最开头（`project(...)` 之前）插入以下配置：

```cmake
cmake_minimum_required(VERSION 3.10)

# ================= 交叉编译配置 (新增) =================
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

# 修改为您解压的实际路径
set(TOOLCHAIN_DIR "/home/topeet/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu")

set(CMAKE_C_COMPILER   "${TOOLCHAIN_DIR}/bin/aarch64-linux-gnu-gcc")
set(CMAKE_CXX_COMPILER "${TOOLCHAIN_DIR}/bin/aarch64-linux-gnu-g++")

# 强制 CMake 只在指定路径查找库，避免链接到 Ubuntu 系统自带的 x86 库
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN_DIR})
# ======================================================

project(FaceRecognition_Core)
# ... 下面保持您原有的内容 ...
```

**第三步：编译与验证**

在 VMWare 终端执行：

```bash
cd face_detection
rm -rf build && mkdir build
cd build
cmake ..
make -j4
```

**验证结果**：

编译成功后，执行以下命令检查生成的库文件格式：

```bash
file libface_engine.so
```
**必须看到**包含 `ARM aarch64` 的字样。如果显示 `x86-64`，说明交叉编译配置未生效

---

### 3. 部署到开发板上还需要修改的内容

当您把文件传输到板子上后，主要解决的是运行时环境问题。

#### 需要传输的文件清单
您不需要传输整个源码，只需要传输以下内容到板子（例如 `/userdata/face_app/`）：
```
/userdata/face_app/
├── libface_engine.so        # 刚刚编译好的核心库
├── models/                  # 包含两个 .rknn 模型
├── test_api.py              # Python 测试脚本
└── third_party/rknn/lib/librknnrt.so  # (可选) 如果板子系统里没有预装这个库，必须带上
```

#### 开发板上的修改与操作

**1. 设置库路径 (LD_LIBRARY_PATH)**

板子在运行 `test_api.py` 时，Python 会加载 `libface_engine.so`，而 `libface_engine.so` 又需要加载 `librknnrt.so`。系统默认可能找不到它们。

**临时方案（推荐测试用）**：

在板子终端运行：

```bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/userdata/face_app:/userdata/face_app/third_party/rknn/lib
```
*(注：将路径替换为您实际存放 `.so` 的路径)*

**2. 安装 Python 依赖**

您的 `test_api.py` 和文档中提到了返回 numpy 数组

```bash
# 在板子上检查是否安装了 numpy
python3 -c "import numpy; print(numpy.__version__)"
```
如果没有安装，您可能需要通过 `pip install numpy` 安装（如果板子有网），或者手动复制 numpy 包进去。

**3. 权限设置**

确保文件有执行权限（虽然 `.so` 和 `.py` 通常不需要 `x` 也能被加载，但如果是直接运行 C++ demo 则需要）：

```bash
chmod +x /userdata/face_app/libface_engine.so
```

**4. 运行测试**
```bash
cd /userdata/face_app
python3 test_api.py --image test.jpg
```

### 总结行动清单

1.  **VMWare**: 按照步骤二，在 CMakeLists.txt 头部加入交叉编译配置块
2.  **VMWare**: 将 ARM64 版本的 OpenCV 和 RKNN 库放入 `third_party`
3.  **VMWare**: 运行 `cmake` 和 `make`，确认生成的是 ARM64 格式的 `.so`
4.  **Transfer**: 将 `.so`、模型文件、Python 脚本推送到开发板
5.  **Board**: 设置 `LD_LIBRARY_PATH` 环境变量
6.  **Board**: 运行 Python 脚本验证