

## 架构图

| 层级          | 模块名称          | 职责描述                                                     |
| :------------ | :---------------- | :----------------------------------------------------------- |
| **L1 接口层** | **FastAPI**       | 处理 HTTP 请求、视频流推流 (MJPEG)、权限验证                 |
| **L2 业务层** | **Service Logic** | 协调摄像头、数据库和 AI 引擎。包含**后台守护线程** (自动开门逻辑) |
| **L3 核心层** | **Core Wrapper**  | `FaceEngine` (Python) + `GlobalCamera` (单例摄像头管理)      |
| **L4 驱动层** | **Native .so**    | C++ 编写的动态库，负责 RKNN 推理、OpenCV 图像处理            |
| **L5 数据层** | **SQLite**        | 存储用户信息、特征向量 (BLOB)、进出日志                      |

## 后端结构

```bash
backend/
├── main.py                  # [入口] FastAPI App, 启动后台线程
├── requirements.txt         # 依赖: fastapi, uvicorn, numpy, opencv-python-headless
├── config.py                # 配置: 阈值, 摄像头ID, GPIO引脚号
│
├── core/                    # [核心逻辑]
│   ├── __init__.py
│   ├── face_engine.py       # ★ Python Wrapper (调用 ctypes)
│   ├── camera.py            # ★ GlobalCamera (单例, 管理 cv2.VideoCapture)
│   └── background_task.py   # ★ 自动开门死循环逻辑
│
├── routers/                 # [API 路由]
│   ├── auth.py              # 登录, 修改密码
│   ├── face.py              # /api/face/capture, /api/face/list
│   ├── stream.py            # /api/video_stream
│   └── monitor.py           # /api/logs, /api/recognize (测试用)
│
├── database/                # [数据库]
│   ├── db_manager.py        # SQLite 增删改查封装
│   └── smart_door.db        # 自动生成
```

### 关键部分



## API 列表

### 模块 A：认证

| HTTP 方法 | URL                          | 功能说明     | 备注                                                 |
| :-------- | :--------------------------- | :----------- | :--------------------------------------------------- |
| **POST**  | `/api/login`                 | 管理员登录   | 输入: `{"pwd": "..."}` <br> 输出: `{"token": "xyz"}` |
| **POST**  | `/api/change_login_password` | 修改登录密码 |                                                      |

### 模块 B：视频流与摄像头

| HTTP 方法 | URL                 | 功能说明          | 备注                          |
| :-------- | :------------------ | :---------------- | :---------------------------- |
| **GET**   | `/api/video_stream` | 提供 MJPEG 视频流 | 前端 `img` 标签直接引用此 URL |

### 模块 C：人脸管理

| HTTP 方法  | URL                 | 功能说明               | 备注                                                         |
| :--------- | :------------------ | :--------------------- | :----------------------------------------------------------- |
| **POST**   | `/api/face/capture` | 触发录入               | 输入: `{"username": "张三"}`<br>**逻辑**：后端收到请求 -> 从全局摄像头对象截取当前这一帧 -> 调 C++ 提取特征 -> 存库 |
| **GET**    | `/api/face/list`    | 获取已录入用户列表     | 返回 `["张三", "李四"]`                                      |
| **DELETE** | `/api/face/reset`   | 重置所有               |                                                              |
| **DELETE** | `/api/face/{name}`  | **新增**。删除指定用户 | 比如 `DELETE /api/face/张三`                                 |

### 模块 D：传统密码与日志（暂时全不实现，优先其他）

| HTTP 方法  | URL               | 功能说明                 | 备注                         |
| :--------- | :---------------- | :----------------------- | :--------------------------- |
| **POST**   | `/api/code/add`   | 录入开门密码             |                              |
| **DELETE** | `/api/code/reset` | 重置所有密码             |                              |
| **GET**    | `/api/logs`       | 获取开门记录（**可选**） | 返回 JSON 列表供前端渲染表格 |

### 模块E：管理员开门

| HTTP 方法 | URL          | 功能说明                         | 备注                              |
| --------- | ------------ | -------------------------------- | --------------------------------- |
| **POST**  | `api/unlock` | | Header: 需携带 Token (`Authorization: Bearer ...`)<br>实现: 使用 `BackgroundTasks` 异步执行，接口立即返回 200，不阻塞前端等待 3 秒 |



## 数据流

#### 数据流 A：实时预览 (MJPEG 流)
*用户在手机网页上看到摄像头画面*

1.  **源头**：`GlobalCamera` (OpenCV) 持续读取 `/dev/video0`
2.  **转换**：将 `cv::Mat` (Raw Data) 编码为 `.jpg` 格式 (Bytes)
3.  **传输**：FastAPI 通过生成器 (`yield`) 将 JPG 拼接到 HTTP `multipart/x-mixed-replace` 流中
4.  **终端**：手机浏览器 `<img src="/api/video_stream">` 接收并渲染

> 数据流向：Camera -> Python Memory -> HTTP Stream -> Phone

#### 数据流 B：人脸录入 (Web 触发)
*管理员点击“录入”按钮，将当前画面存入库*

1.  **触发**：手机发送 `POST /api/face/capture` (带用户名)
2.  **截取**：FastAPI 从 `GlobalCamera` 获取**当前最新一帧** (Numpy Array)
3.  **编码**：使用 `cv2.imencode` 将帧转为 **Bytes** (模拟图片文件)
4.  **推理**：调用 `FaceEngine.extract_feature(bytes)`
    
    *C++ 内部*：`imdecode` -> RetinaFace -> Alignment -> MobileFaceNet -> Vector
5.  **存储**：将返回的 `512维 List` 转为二进制 (`tobytes()`) 存入 SQLite。

> 数据流向：Phone (指令) -> Camera Frame -> C++ Engine -> Feature Vector -> SQLite

#### 数据流 C：自动守卫 (后台线程)
*完全脱离手机，设备自主运行的开门逻辑*

1.  **循环**：`Background Thread` 每 100ms 检查一次
2.  **检测**：调用 `GlobalCamera` 判断画面是否有变动 (移动侦测)
3.  **获取**：若有人，获取当前帧 -> `cv2.imencode` -> **Bytes**
4.  **推理**：调用 `FaceEngine.extract_feature(bytes)` (复用同一个引擎实例)
5.  **比对**：从 SQLite 拉取所有用户的向量，计算余弦相似度
6.  **执行**：若相似度 > 0.5，控制 **GPIO** 输出高电平开锁

> 数据流向：Camera -> Background Thread -> C++ Engine -> Vector -> DB Search -> GPIO

## 业务流程

### 路线一：日常自动开门（核心业务）

- **场景**：你走到门口，门自动开了。
- **流程**：
  1. OV5695 摄像头（直连 RK3568）不断采集画面
  2. 后台线程（Python while True 循环）拿到画面
  3. 后台线程 直接调用 C++ 模块 (face_app.extract_feature)
  4. 后台线程 拿着结果去本地数据库比对
  5. 后台线程 比对成功，控制 **GPIO** 引脚，门锁打开
- 特点：极速、本地化、断网也能用、不需要手机参与

### 路线二：HTTP API 交互（管理与测试）

- **场景 A：录入人脸 （/api/face/capture）**
  - 管理员登录面板，点击录入人脸，在手机上查看返回的图像流（视频），喊一声“看镜头”，然后点“录入”
  - 手机发送 HTTP 指令 -> RK3568 截帧 -> 人脸识别模块处理得到向量 -> 存入数据库
- **场景 B：管理员远程开门（/api/unlock）**
  - 管理员登录面板，直接发出解锁指令
  - 手机发送 HTTP POST 指令 -> RK3568 校验管理员权限 -> 触发 GPIO 控制器动作

- **场景 C：远程测试 （/api/face/recognize）**
  - 管理员想测试一下系统准不准，或者想远程帮人验证一张照片
  - 管理员在手机/电脑上传一张图片 -> 发送 HTTP 请求 -> RK3568 计算并返回 JSON 结果 ("这是张三，相似度 0.9")
  - **注意**：这个接口通常只返回结果，不触发 GPIO 开门（除非你特意写了逻辑让它开）



## 注意事项（必看）

1. GPIO传统密码录入部分可能来不及做，先把核心的人脸识别部分打通。

## 可能存在的问题

### GPIO控制冲突

**问题描述**：

本系统存在两个并发的触发源试图控制同一个硬件资源（GPIO 门锁引脚）：
1.  **后台守护线程 (Background Daemon)**：当 NPU 人脸识别通过后，自动触发开门
2.  **Web API 线程 (FastAPI)**：当管理员调用 `/api/unlock` 接口时，手动触发开门

**风险**：

如果不加以控制，当“人脸识别成功”与“管理员点击按钮”几乎同时发生时，两个线程会同时尝试向 GPIO 写入高/低电平。这会导致：

*   **资源竞争**：GPIO 库可能会报错（Resource busy）
*   **状态异常**：门锁可能会快速反复跳变，或者无法正确关闭

**解决方案（后端逻辑）**：

必须实现一个**单例模式** 的 `DoorController` 类，并内部维护一个 **线程锁 (`threading.Lock`)**
*   无论是 API 还是后台线程，想要开门都必须调用 `DoorController.open()`
*   该方法在执行期间（开锁 -> `sleep(3)` -> 关锁）会锁定资源，如果此时有第二个请求进来，直接返回“忙碌”或丢弃该请求

---



 

## 总结

  1. 新增功能模块

  - 模块E：管理员远程开门 (POST /api/unlock)
    - 需要 Token 认证
    - 使用 BackgroundTasks 异步执行，接口立即返回，不阻塞前端

  2. 调整优先级

  - 模块D（传统密码与日志）暂不实现
    - /api/code/add、/api/code/reset、/api/logs 延后开发
    - 优先完成核心人脸识别功能

  3. 新增架构组件

  - DoorController 类（需要新增）
    - 单例模式
    - 使用 threading.Lock 解决 GPIO 控制冲突
    - 统一管理后台线程和 API 的开门请求

  4. 业务流程明确化

  - 场景 A：录入人脸（从视频流截帧）
  - 场景 B：管理员远程开门（新增）
  - 场景 C：远程测试识别（仅返回结果，不开门）

  更新后的开发任务清单

● 已更新开发任务清单。与之前相比，主要调整如下：

  新增任务

  1. config.py - 配置管理（阈值、摄像头ID、GPIO引脚号）
  2. core/door_controller.py - GPIO控制器（单例模式 + 线程锁，解决并发冲突）
  3. routers/unlock.py - 管理员远程开门接口

  删除/延后的任务

  - 日志查询功能 (/api/logs) - 暂不实现
  - 传统密码录入 (/api/code/*) - 暂不实现

  调整的任务

  - routers/auth.py - 只实现登录和修改密码（不含权限管理）
  - database/db_manager.py - 不需要实现日志表和传统密码表

  核心架构要点

  DoorController 类（新增重点）

  class DoorController:
      """GPIO门锁控制器（单例模式）"""
      _instance = None
      _lock = threading.Lock()  # 防止并发冲突

      def open(self):
          """开门（3秒后自动关闭）"""
          with self._lock:
              # 设置GPIO高电平
              # time.sleep(3)
              # 设置GPIO低电平

  作用：确保后台线程和Web API不会同时操作GPIO引脚。

---
  当前任务状态：正在实现 database/db_manager.py

  需要我继续实现数据库模块吗？还是你想先调整其他部分？

  Todos
  [ ] 实现 config.py（配置：阈值、摄像头ID、GPIO引脚号）
  [ ] 实现 database/db_manager.py（SQLite 增删改查封装）
  [ ] 实现 core/camera.py（GlobalCamera 单例，管理 cv2.VideoCapture）
  [ ] 实现 core/door_controller.py（DoorController 单例，GPIO控制 + 线程锁）
  [ ] 实现 routers/stream.py（MJPEG 视频流：GET /api/video_stream）
  [ ] 实现 routers/face.py（人脸管理：capture、list、reset、delete）
  [ ] 实现 routers/auth.py（登录和修改密码）
  [ ] 实现 routers/unlock.py（管理员远程开门：POST /api/unlock）
  [ ] 实现 core/background_task.py（自动开门后台线程）
  [ ] 实现 main.py（FastAPI App 入口，注册路由，启动后台线程）
  [ ] 集成测试和部署到 RK3568